from dm_control import mujoco
import cv2
import numpy as np
import random

from piper_util.piper_util import *

# Load dm_control model
model = mujoco.Physics.from_xml_path('assets/piper_rrt.xml')


class RRT:
    class Node:
        def __init__(self, q):
            self.q = q           # 关节角度配置
            self.path_q = []     # 从父节点到该节点的路径
            self.parent = None   # 父节点

    def __init__(self, start, goal, joint_limits, expand_dis=0.1, path_resolution=0.01, goal_sample_rate=5, max_iter=1000):
        self.start = self.Node(start)
        self.end = self.Node(goal)
        self.joint_limits = joint_limits
        self.expand_dis = expand_dis
        self.path_resolution = path_resolution
        self.goal_sample_rate = goal_sample_rate
        self.max_iter = max_iter
        self.node_list = []

    def planning(self, model):
        self.node_list = [self.start]
        for i in range(self.max_iter):
            rnd_node = self.get_random_node()
            nearest_ind = self.get_nearest_node_index(self.node_list, rnd_node)
            nearest_node = self.node_list[nearest_ind]

            new_node = self.steer(nearest_node, rnd_node, self.expand_dis)

            if self.check_collision(new_node, model):
                self.node_list.append(new_node)

            if self.calc_dist_to_goal(self.node_list[-1].q) <= self.expand_dis:
                final_node = self.steer(self.node_list[-1], self.end, self.expand_dis)
                if self.check_collision(final_node, model):
                    return self.generate_final_course(len(self.node_list) - 1)

        return None

    def get_nearest_node_index(self, node_list, rnd_node):
        """
        Find the index of the nearest node to the random node.
        
        Args:
            node_list: List of nodes in the RRT tree.
            rnd_node: Randomly generated node.
        
        Returns:
            Index of the nearest node in the node list.
        """
        dlist = [np.linalg.norm(np.array(node.q) - np.array(rnd_node.q)) for node in node_list]
        min_index = dlist.index(min(dlist))
        return min_index
    
    def steer(self, from_node, to_node, extend_length=float("inf")):
        new_node = self.Node(np.array(from_node.q))
        distance = np.linalg.norm(np.array(to_node.q) - np.array(from_node.q))
        if extend_length > distance:
            extend_length = distance
        num_steps = int(extend_length / self.path_resolution)
        delta_q = (np.array(to_node.q) - np.array(from_node.q)) / distance

        for i in range(num_steps):
            new_q = new_node.q + delta_q * self.path_resolution
            new_node.q = np.clip(new_q, [lim[0] for lim in self.joint_limits], [lim[1] for lim in self.joint_limits])
            new_node.path_q.append(new_node.q)

        new_node.parent = from_node
        return new_node

    def get_random_node(self):
        if random.randint(0, 100) > self.goal_sample_rate:
            rand_q = [random.uniform(joint_min, joint_max) for joint_min, joint_max in self.joint_limits]
        else:
            rand_q = self.end.q
        return self.Node(rand_q)

    def check_collision(self, node, model):
        return check_collision_with_dm_control(model, node.q)

    def generate_final_course(self, goal_ind):
        path = [self.end.q]
        node = self.node_list[goal_ind]
        while node.parent is not None:
            path.append(node.q)
            node = node.parent
        path.append(self.start.q)
        return path[::-1]

    def calc_dist_to_goal(self, q):
        return np.linalg.norm(np.array(self.end.q) - np.array(q))


def check_collision_with_dm_control(model, joint_config):
    """
    Function to check if a given joint configuration results in a collision using dm_control's collision detection.
    Args:
        model: dm_control Mujoco model
        joint_config: List of joint angles to check for collision
    Returns:
        True if collision-free, False if there is a collision
    """
    model.data.qpos[:] = joint_config  # Set joint positions
    model.forward()  # Update the simulation state

    # Check for collisions
    contacts = model.data.ncon  # Number of contacts (collisions)
    return contacts == 0  # True if no contacts (collision-free)



def apply_rrt_path_to_dm_control(model, path, video_name="rrt_robot_motion.mp4"):
    """
    Function to apply the RRT-generated path (list of joint configurations) to the dm_control simulation,
    while recording the frames into a video.
    
    Args:
        model: dm_control Mujoco model
        path: List of joint configurations generated by the RRT planner
        video_name: Name of the output video file
    """
    # Setup for video recording
    width, height = 640, 480  # Resolution of each camera
    fourcc = cv2.VideoWriter_fourcc(*'mp4v')  # Codec for mp4
    out = cv2.VideoWriter(video_name, fourcc, 20.0, (1280, 480))  # Two 640x480 images side by side

    # set initial joint angles
    model.data.qpos[:] = start
    model.forward()

    # Apply the path to the simulation and record the video
    for q in path:
        # Check joint limits
        
        # print(f"{q=}")

        # model.data.qpos[:] = q  # Set joint angles
        model.data.ctrl[:] = q  # Set joint angles
        
        # Render from both cameras and concatenate side by side
        frame_1 = model.render(camera_id=0, width=width, height=height)
        frame_2 = model.render(camera_id=1, width=width, height=height)
        frame_combined = np.concatenate((frame_1, frame_2), axis=1)
        
        # Convert frame from RGB to BGR for OpenCV
        frame_bgr = cv2.cvtColor(frame_combined, cv2.COLOR_RGB2BGR)
        
        # Write the frame to the video
        out.write(frame_bgr)

        # Step the simulation forward to the next state
        model.step()

    # Release the video writer
    out.release()
    print(f"Video saved as {video_name}")



if __name__ == "__main__":
    # Example usage:
    start = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]  # Start joint angles
    # goal = [0, 1.50603839, -0.26118674, 0, -1.13815009, 0]  # Goal joint angles
    goal = [-0.67066075, 1.38224431, -0.87740199, 0.63781279, -1.22, 0.88061223]  # Goal joint angles


    piper = C_PiperInterface("can0")
    piper.ConnectPort()
    piper.EnableArm(7)
    enable_fun(piper=piper)
    # piper.DisableArm(7)
    piper.GripperCtrl(0,1000,0x01, 0)
    factor = 57295.7795 #1000*180/3.1415926
    # factor =1
    position = [0,0,0,0,0,0,0]

    # goal = [-0.511, 0.544, -1.18, 0.0, 0.0, 0.0]
    joint_limits = [(-3, 3)] * 6  # Example joint limits
    joint_limits[0] = (-2.687, 2.687) # elbow
    joint_limits[1] = (0.0, 3.403) 
    joint_limits[2] = (-3.0541012, 0.0) 
    joint_limits[3] = (-1.8499, 1.8499) 
    joint_limits[4] = (-1.3089, 1.3089) 
    joint_limits[5] = (-1.7452, 1.7452) 

    # Initialize RRT (assuming you have the RRT class set up)
    rrt = RRT(start, goal, joint_limits)
    rrt_path = rrt.planning(model)  # Generate the RRT path
    print("----------")
    print(type(rrt_path))
    print(len(rrt_path))
    # print(rrt_path)



    if rrt_path:
        print("Path found!")
        # apply_rrt_path_to_dm_control(model, rrt_path, video_name="rrt_robot_motion.mp4")


        for point in rrt_path:
            # print(point)  # 打印每个路径点
            joint_0 = round(point[0]*factor)
            joint_1 = round(point[1]*factor)
            joint_2 = round(point[2]*factor)
            joint_3 = round(point[3]*factor)
            joint_4 = round(point[4]*factor)
            joint_5 = round(point[5]*factor)
            joint_6 = round(0.0*1000*1000)
            # piper.MotionCtrl_1()
            piper.MotionCtrl_2(0x01, 0x01, 5, 0x00)
            piper.JointCtrl(joint_0, joint_1, joint_2, joint_3, joint_4, joint_5)
            piper.GripperCtrl(abs(joint_6), 1000, 0x01, 0)
            time.sleep(0.005)
            pass


        
    else:
        print("No path found!")